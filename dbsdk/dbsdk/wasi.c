// See emscripten's wasi/api.h: https://github.com/emscripten-core/emscripten/blob/main/system/include/wasi/api.h
#include <wasi/api.h>
#include <stdint.h>
// Used by `__wasi_clock_time_get`.
#include "db_clock.h"

// Always succeeds, sets argc and argv_buf_size to zero.
__wasi_errno_t __wasi_args_sizes_get(__wasi_size_t *argc, __wasi_size_t *argv_buf_size) {
    *argc = 0;
    *argv_buf_size = 0;
    return __WASI_ERRNO_SUCCESS;
}

// Always succeeds. Due to `args_sizes_get` always returning a zero arg count,
// this function should never be called by the generated C code. Leaves the
// arguments untouched.
__wasi_errno_t __wasi_args_get(uint8_t **argv, uint8_t *argv_buf) {
    return __WASI_ERRNO_SUCCESS;
}

// Traps. Technically not correct, but has a similar effect... NOTE: DreamBox
// doesn't seem to provide a way for games to shutdown the console, so
// crashing is the next best thing!
_Noreturn void __wasi_proc_exit(__wasi_exitcode_t rval) {
  __builtin_trap();
}

// Calls out to DBSDK's clock_getTimestamp() function. Ignores the precision
// parameter.
__wasi_errno_t __wasi_clock_time_get(__wasi_clockid_t id, __wasi_timestamp_t precision, __wasi_timestamp_t *time) {
    // MONOTONIC only.
    if (id != __WASI_CLOCKID_MONOTONIC) return __WASI_ERRNO_INVAL;

    *time = (__wasi_timestamp_t)(clock_getTimestamp() * 1000000000); // 1 second == 1e9 nano-seconds
    return __WASI_ERRNO_SUCCESS;
}

// The clock is based on DBSDK's clock_getTimestamp() function which provides
// seconds-level resolution.
__wasi_errno_t __wasi_clock_res_get(__wasi_clockid_t id, __wasi_timestamp_t *resolution) {
    // MONOTONIC only.
    if (id != __WASI_CLOCKID_MONOTONIC) return __WASI_ERRNO_INVAL;
    *resolution = 1000000000; // 1 second == 1e9 nano-seconds.
    return __WASI_ERRNO_SUCCESS;
}

// Always succeeds, sets envc and envv_buf_size to zero.
__wasi_errno_t __wasi_environ_sizes_get(__wasi_size_t *envc, __wasi_size_t *envv_buf_size) {
    *envc = 0;
    *envv_buf_size = 0;
    return __WASI_ERRNO_SUCCESS;
}

// Always succeeds. Due to `environ_sizes_get` always returning a zero env count,
// this function should never be called by the generated C code. Leaves the
// arguments untouched.
__wasi_errno_t __wasi_environ_get(uint8_t **environ, uint8_t *environ_buf) {
    return __WASI_ERRNO_SUCCESS;
}

// Traps. An alternative is provided by DreamBox so the family of fd_*
// functions referenced in the Wasm generated by Koka should never actually be
// used. Therefore, the argument is left untouched.
// NOTE: Only a subset of the Koka stdlib is shipped so it should not be
// possible to call these functions.
__wasi_errno_t __wasi_fd_close(__wasi_fd_t fd) {
    __builtin_trap();
}

// Traps. Shouldn't ever be used as DreamBox provides alternatives.
// Arguments are left untouched.
__wasi_errno_t __wasi_fd_read(__wasi_fd_t fd, const __wasi_iovec_t *iovs, size_t iovs_len, __wasi_size_t *nread) {
    __builtin_trap();
}

// Traps. Shouldn't ever be used as DreamBox provides alternatives.
// Arguments are left untouched.
__wasi_errno_t __wasi_fd_write(__wasi_fd_t fd, const __wasi_ciovec_t *iovs, size_t iovs_len, __wasi_size_t *nwritten) {
    __builtin_trap();
}

// Traps. Shouldn't ever be used as DreamBox provides alternatives.
// Arguments are left untouched.
__wasi_errno_t __wasi_fd_seek(__wasi_fd_t fd, __wasi_filedelta_t offset, __wasi_whence_t whence, __wasi_filesize_t *newoffset) {
    __builtin_trap();
}
