/*==============================================================================
 Wat Patcher
 ----------
 Inject the custom Wasi implementation into the wasm module generated by Koka.
 
 TODO
 ----
 + Remove testing code.
 + Add tests.
 =============================================================================*/

module wat/patcher

import wat/parser

fun (==)(lhs: wasm-type, rhs: wasm-type): bool
  match (lhs, rhs)
    (I32, I32) -> True
    (I64, I64) -> True
    (F32, F32) -> True
    (F64, F64) -> True
    _ -> False

fun (==)(lhs: func-type, rhs: func-type): bool
  val do-params-match = match (lhs.params, rhs.params)
    (Just(lps), Just(rps)) ->
      if lps.length == rps.length then
        lps.zip(rps)
           .all(fn((lt, rt)) {lt == rt})
      else
        False
    (Nothing, Nothing) -> True
    _ -> False

  val do-results-match = match (lhs.results, rhs.results)
    (Just(lrs), Just(rrs)) ->
      if lrs.length == rrs.length then
        lrs.zip(rrs)
           .all(fn((lt, rt)) {lt == rt})
      else
        False
    (Nothing, Nothing) -> True
    _ -> False

  do-params-match && do-results-match

fun (==)(lhs: module-field, rhs: module-field): bool
  match (lhs, rhs)
    (Type(_, _, ltyp), Type(_, _, rtyp)) -> ltyp == rtyp
    _ -> False

fun field-list-contains(typs: list<module-field>, target: module-field)
  any(typs) fn(typ)
    typ == target

pub fun patch(target: list<module-field>, wasi: list<module-field>)
  val target-types = filter(target, is-type)
  val wasi-types = filter(wasi, is-type)
  val new-types = remove(wasi-types, fn(wt) {field-list-contains(target-types, wt)})
  ()

fun main()
  val t1 = Type("", 0, Func-type(Just([I32]), Just([I32])))
  val w1 = Type("", 0, Func-type(Just([I32]), Just([I32])))
  val t2 = Type("", 0, Func-type(Just([I32]), Nothing))
  val w2 = Type("", 0, Func-type(Just([I32]), Nothing))
  val t3 = Type("", 0, Func-type(Nothing, Just([I32])))
  val w3 = Type("", 0, Func-type(Nothing, Just([I32])))
  val t4 = Type("", 0, Func-type(Nothing, Nothing))
  val w4 = Type("", 0, Func-type(Nothing, Nothing))
  val t5 = Type("", 0, Func-type(Just([I32]), Just([I32, F64])))
  val w5 = Type("", 0, Func-type(Just([I32]), Just([I32])))
  val t6 = Type("", 0, Func-type(Just([I32]), Just([I32])))
  val w6 = Type("", 0, Func-type(Just([I32, F64]), Just([I32])))
  val t7 = Type("", 0, Func-type(Just([I32]), Just([I32])))
  val w7 = Type("", 0, Func-type(Just([I64]), Just([I32])))
  val new-types = remove([t1, t2, t3], fn(wt) {field-list-contains([t4, t3, t5], wt)})
  if t1 == w1 then println("Test 1: Success") else println("Test 1: Failed")
  if t2 == w2 then println("Test 2: Success") else println("Test 2: Failed")
  if t3 == w3 then println("Test 3: Success") else println("Test 3: Failed")
  if t4 == w4 then println("Test 4: Success") else println("Test 4: Failed")
  if (t5 == w5).is-false then println("Test 5: Success") else println("Test 5: Failed")
  if (t6 == w6).is-false then println("Test 6: Success") else println("Test 6: Failed")
  if (t7 == w7).is-false then println("Test 7: Success") else println("Test 7: Failed")
  println(new-types.length.show)