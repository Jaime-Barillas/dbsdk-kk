/*==============================================================================
 Wat Patcher
 ----------
 Inject the custom Wasi implementation into the wasm module generated by Koka.
 
 TODO
 ----
 + Update comment blocks in the sources of module-fields from the Wasi code
   which mention their type/func index to use their new index after being
   inserted into the main wasm module.
 + Remove testing code.
 + Add tests.
 =============================================================================*/

module wat/patcher

import wat/parser

fun (==)(lhs: wasm-type, rhs: wasm-type): bool
  match (lhs, rhs)
    (I32, I32) -> True
    (I64, I64) -> True
    (F32, F32) -> True
    (F64, F64) -> True
    _ -> False

fun (==)(lhs: func-type, rhs: func-type): bool
  val do-params-match = match (lhs.params, rhs.params)
    (Just(lps), Just(rps)) ->
      if lps.length == rps.length then
        lps.zip(rps)
           .all(fn((lt, rt)) {lt == rt})
      else
        False
    (Nothing, Nothing) -> True
    _ -> False

  val do-results-match = match (lhs.results, rhs.results)
    (Just(lrs), Just(rrs)) ->
      if lrs.length == rrs.length then
        lrs.zip(rrs)
           .all(fn((lt, rt)) {lt == rt})
      else
        False
    (Nothing, Nothing) -> True
    _ -> False

  do-params-match && do-results-match

fun (==)(lhs: module-field, rhs: module-field): bool
  match (lhs, rhs)
    (Type(_, _, ltyp), Type(_, _, rtyp)) -> ltyp == rtyp
    (Import(_, _, lname, _), Import(_, _, rname, _)) -> lname == rname
    _ -> False

fun contains(typs: list<module-field>, target: module-field)
  any(typs) fn(typ)
    typ == target

// These `list<module-field>`s should be a list of `Type`s.
fun add-wasi-type-fields(target: list<module-field>, wasi: list<module-field>)
  val last-idx = match target.last
    Nothing -> 0
    Just(typ) ->
      match typ
        Type(_, idx, _) -> idx
        _ -> 0
  val missing-types = wasi.remove(fn(typ) target.contains(typ))
                          .map-indexed(fn(i, Type(a, _, c)) { // Destructuring here causes exn effect
                            Type(a, (1 + i + last-idx), c)
                          })
  target ++ missing-types

fun get-func-type-idx(f: module-field)
  match f
    Func(_, _, typ-idx) -> Just(typ-idx)
    _ -> Nothing

fun get-func-type(wasi-types: list<module-field>, idx: maybe<int>)
  match idx
    Nothing -> Nothing
    Just(i) ->
      wasi-types.find fn(typ)
        // Could also rely on the Type's index within the wasi-types list.
        // It should mirror the actual type field's index, but this is safer.
        match typ
          Type(_, widx, _) -> i == widx
          _ -> False
      // Relying on the type's index within the wasi-types list:
      //match wasi-types[i]
      //  Nothing -> Nothing
      //  Just(ft) -> Just(ft)

fun get-matching-type(target-types: list<module-field>, wasi-type: maybe<module-field>)
  match wasi-type
    Nothing -> Nothing
    Just(wtyp) -> target-types.find(fn(ttyp) ttyp == wtyp)

fun get-type-id(f: maybe<module-field>)
  match f
    Nothing -> -1 // FIXME: Some better way to signal an error.
    Just(f') ->
      match f'
        Type(_, idx, _) -> idx
        _ -> -1 // FIXME: Some better way to signal an error.

fun set-new-func-type-idx(idx: int, func: module-field, new-typ-idx: list<int>)
  match func
    Func(src, fidx, typ-idx) ->
      val new-idx = new-typ-idx[idx].default(-1)
      val new-src = src.replace-all("(type " ++ typ-idx.show ++ ")", "(type " ++ new-idx.show ++ ")")
      Func(new-src, fidx, new-idx)
    _ -> func

fun update-wasi-func-types(target-types: list<module-field>, wasi-funcs: list<module-field>, wasi-types: list<module-field>)
  val idxs = wasi-funcs.map(get-func-type-idx)
                       .map(fn(typ-idx) get-func-type(wasi-types, typ-idx))
                       .map(fn(typ) get-matching-type(target-types, typ))
                       .map(get-type-id)
  wasi-funcs.map-indexed(fn(idx, wf) set-new-func-type-idx(idx, wf, idxs))

fun get-import-type-idx(im: module-field)
  match im
    Import(_, _, _, typ-idx) -> Just(typ-idx)
    _ -> Nothing

fun set-new-import-type-idx(idx: int, im: module-field, new-typ-idx: list<int>)
  match im
    Import(src, iidx, name, typ-idx) ->
      val new-idx = new-typ-idx[idx].default(-1)
      val new-src = src.replace-all("(type " ++ typ-idx.show ++ ")", "(type " ++ new-idx.show ++ ")")
      Import(new-src, iidx, name, new-idx)
    _ -> im

fun update-wasi-import-types(target-types: list<module-field>, wasi-imports: list<module-field>, wasi-types: list<module-field>)
  val idxs = wasi-imports.map(get-import-type-idx)
                         .map(fn(typ-idx) get-func-type(wasi-types, typ-idx))
                          // FIXME: Do above wasi-type may not exist in below target type!
                         .map(fn(typ) get-matching-type(target-types, typ))
                         .map(get-type-id)
  wasi-imports.map-indexed(fn(idx, wi) set-new-import-type-idx(idx, wi, idxs))

fun append-wasi-imports(target-funcs: list<module-field>, wasi-imports: list<module-field>, target-imports: list<module-field>)
  val last-idx = match target-funcs.last
    Nothing -> 0 // FIXME: Wrong should be (last imports index) + 1
    Just(typ) ->
      match typ
        Func(_, idx, _) -> idx
        _ -> 0 // FIXME: Wrong should be (last imports index) + 1
  val missing-imports = wasi-imports.remove(fn(typ) target-imports.contains(typ))
                                    .map-indexed(fn(i, Import(a, _, c, d)) {
                                      Import(a, (1 + i + last-idx), c, d)
                                    })
  target-funcs ++ missing-imports

fun get-matching-func(funcs: list<module-field>, func-idx: int)
  funcs.find fn(func)
    match func
      Func(fsrc, fidx, tidx) -> fidx == func-idx
      _ -> False

// This is GROOOOOOOOOOOOOSSSSSSSSS
fun insert-wasi-funcs(target-imports: list<module-field>, wasi-funcs: list<module-field>, wasi-exports: list<module-field>)
  val funcs = wasi-exports.map(fn(exp) {
    match exp
      Export(_, name, func-idx) ->
        match get-matching-func(wasi-funcs, func-idx)
          Just(f) -> Just((name, f))
          Nothing -> Nothing
      _ -> Nothing
  })
  target-imports.foldl([]) fn(acc, im)
    match im
      Import(_, _, name, _typ-idx) ->
        val mmp = funcs.find fn(maybe-pair)
          match maybe-pair
            Just((n', _)) -> name == n'
            Nothing -> False
        val f = mmp.default(Nothing)
        match f
          Just((_, f)) -> acc ++ [f]
          Nothing -> acc ++ [im]
      im -> acc ++ [im]

//fun update-clock-getTimestamp-call(imports-and-funcs: list<module-field>)
//  val clock-getTimestamp = imports-and-funcs.filter(is-import).find fn(im)
//    match im
//      Import(_, _, name, _) -> name == "clock_getTimestamp"
//      _ -> False
//  val clock-time-get = imports-and-funcs.filter(is-func).find

pub fun patch(target: list<module-field>, wasi: list<module-field>)
  val target-types = filter(target, is-type)
  val wasi-types = filter(wasi, is-type)
  val new-types = target-types.add-wasi-type-fields(wasi-types)

  val wasi-funcs = filter(wasi, is-func)
  val updated-wasi-funcs = update-wasi-func-types(new-types, wasi-funcs, wasi-types)
  // TODO: Update call from clock_gettime to db_getTimestamp to use new func idx. Do it after inserting wasi imports.
  
  val wasi-imports = filter(wasi, is-import)
  val updated-wasi-imports = update-wasi-import-types(new-types, wasi-imports, wasi-types)
  
  val target-imports = filter(target, is-import)
  val target-funcs = filter(target, is-func)
  val new-funcs = target-funcs.append-wasi-imports(updated-wasi-imports, target-imports)

  val wasi-exports = filter(wasi, is-export)
  val new-imports = target-imports.insert-wasi-funcs(updated-wasi-funcs, wasi-exports)

  // TODO: Update call from clock_gettime to db_getTimestamp to use new func idx. Do it after inserting wasi imports.
  //  ->>  Filter all new-imports + new-funcs for imports -> get idx of matching import -> string replace
  new-types ++ new-imports ++ new-funcs

// TODO: DONE! - Update type index of wasi file's functions IN THE SRC TEXT.
//       Undo above and instead perform the type index update when inserting the exported function (I have access to the new type idx here)
//       DONE! - Update type index of wasi file's imports IN THE SRC TEXT. (clock_gettime's call to db_getTimestamp which needs the new type idx from target)
//       DONE! - Add new wasi imports to target's func list after all other _funcs_.
//       Update clock_gettime's call to db_getTimestamp to use new func index of import as target sees it.
//         NOTE: None of the Wasi functions call eachother, so only the above update needs to touch
//               the source text of the functions.
//       DONE! - Grab list of exported functions from the wasi file
//       DONE! - Replace target's imports with corresponding functions from the wasi file

fun main()
  val t1 = Type("", 0, Func-type(Just([I32]), Just([I32])))
  val w1 = Type("", 3, Func-type(Just([I32]), Just([I32])))
  val t2 = Type("", 1, Func-type(Just([I32]), Nothing))
  val w2 = Type("", 4, Func-type(Just([I32]), Nothing))
  val t3 = Type("", 2, Func-type(Nothing, Just([I32])))
  val w3 = Type("", 5, Func-type(Nothing, Just([I32])))
  val t4 = Type("", 3, Func-type(Nothing, Nothing))
  val w4 = Type("", 6, Func-type(Nothing, Nothing))
  val t5 = Type("", 4, Func-type(Just([I32]), Just([I32, F64])))
  val w5 = Type("", 7, Func-type(Just([I32]), Just([I32])))
  val t6 = Type("", 5, Func-type(Just([I32]), Just([I32])))
  val w6 = Type("", 8, Func-type(Just([I32, F64]), Just([I32])))
  val t7 = Type("", 6, Func-type(Just([I32]), Just([I32])))
  val w7 = Type("", 9, Func-type(Just([I64]), Just([I32])))
  if t1 == w1 then println("Test 1: Success") else println("Test 1: Failed")
  if t2 == w2 then println("Test 2: Success") else println("Test 2: Failed")
  if t3 == w3 then println("Test 3: Success") else println("Test 3: Failed")
  if t4 == w4 then println("Test 4: Success") else println("Test 4: Failed")
  if (t5 == w5).is-false then println("Test 5: Success") else println("Test 5: Failed")
  if (t6 == w6).is-false then println("Test 6: Success") else println("Test 6: Failed")
  if (t7 == w7).is-false then println("Test 7: Success") else println("Test 7: Failed")
  println("With wasi  : " ++ [t5, t2, t3].my-show-list(string))
  println("With target: " ++ [t4, t3, t5].my-show-list(string))
  println("New types  : " ++ add-wasi-type-fields([t4, t3, t5], [t5, t2, t3]).my-show-list(string))
  println("======================")
  val w-funcs = [Func("", 0, 3), Func("", 1, 4)]
  val n-funcs = update-wasi-func-types([t1, t2, t3], w-funcs, [w1, w2, w3])
  println("Before: " ++ w-funcs.show-list(string))
  println("After : " ++ n-funcs.show-list(string))
  println("======================")
  val w-imports = [Import("", 0, "a", 3), Import("", 1, "b", 4)]
  val n-imports = update-wasi-import-types([t1, t2, t3], w-imports, [w1, w2, w3])
  println("Before: " ++ w-imports.show-list(string))
  println("After : " ++ n-imports.show-list(string))
  println("======================")
  val n-funcs2 = append-wasi-imports([Func("", 0, 0)], w-imports, [Import("", 7, "a", 4)])
  println("Should contain 2: " ++ n-funcs2.show-list(string))
  println("======================")
  val iwf-target-imports = [Import("", 0, "funca", 0), Import("", 0, "funcb", 1), Import("", 0, "funcc", 2)]
  val iwf-wasi-funcs = [Func("", 2, 1), Func("", 3, 2), Func("", 4, 3)]
  val iwf-wasi-exports = [Export("", "funcb", 3), Export("", "funcd", 4)]
  val n-imports = insert-wasi-funcs(iwf-target-imports, iwf-wasi-funcs, iwf-wasi-exports)
  println("Before inserting: " ++ iwf-target-imports.show-list(string))
  println("After: " ++ n-imports.my-show-list(string))

fun string(p: wasm-type): string
  match p
    I32 -> "I32"
    I64 -> "I64"
    F32 -> "F32"
    F64 -> "F64"

fun string(ft: func-type): string
  val param-string = ft.params.map fn(ps)
                       ps.map(string)
                         .join(" ")
  val result-string = ft.results.map fn(rs)
                        rs.map(string)
                          .join(" ")
  "P(" ++ param-string.default("") ++ "), R(" ++ result-string.default("") ++ ")"

fun string(f: module-field): string
  match f
    Type(_, idx, ft) -> "T(" ++ idx.show ++ "): " ++ ft.string
    Import(_, idx, _, typ-idx) -> "I(" ++ idx.show ++ ", " ++ typ-idx.show ++ ")"
    Func(_, idx, typ-idx) -> "F(" ++ idx.show ++ ", " ++ typ-idx.show ++ ")"
    _ -> "Unknown"

fun my-show-list(xs: list<a>, show-fn: a -> e string): e string
  val list-string = xs.map(show-fn)
                      .join("\t")
  "[" ++ list-string ++ "]"