/*==============================================================================
 Wat Parser
 ----------
 Parse the subset of Wasm text format generated by running wasm2wat on
 WebAssembly generated by the Koka compiler. The code here is not very Koka
 idiomatic.
 
 TODO
 ----
 + Remove testing code.
 + Add tests.
 =============================================================================*/
module wat/parser

import std/text/parse

import std/os/env // FIXME: DELETE ME

type wasm-type
  I32
  I64
  F32
  F64

alias wasm-type-list = maybe<list<wasm-type>>

struct func-type
  params: wasm-type-list
  results: wasm-type-list

type module-field
  Module(src: string) // The module itself.
  Type(src: string, idx: int, typ: func-type)
  Import(src: string)
  Func(src: string)
  Other(src: string)

effect fun save(it: module-field): ()

fun match-idx-comment(): parse (string, int)
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(;")
  val idx = pnat()
  src := src ++ idx.show
  src := src ++ pstring(";)")
  (src, idx)

fun match-type-id(): _ (string, wasm-type)
  var src := ""
  src := src ++ whitespace()
  val typ-string = choose([{pstring("i32")},
                           {pstring("i64")},
                           {pstring("f32")},
                           {pstring("f64")}])
  val typ = match typ-string
    "i32" -> I32
    "i64" -> I64
    "f32" -> F32
    "f64" -> F64
    typ -> fail("Unknown Wasm type: " ++ typ)
  src := src ++ typ-string
  (src, typ)

fun match-func-params(): _ maybe<(string, list<wasm-type>)>
  var src := ""
  var typs := []
  src := src ++ whitespace()
  src := src ++ pstring("(param")
  val params = many1(match-type-id)
  params.foreach fn((psrc, ptyp))
    src := src ++ psrc
    typs := Cons(ptyp, typs)
  src := src ++ pstring(")")
  Just((src, typs.reverse))

fun match-func-results(): _ maybe<(string, list<wasm-type>)>
  var src := ""
  var typs := []
  src := src ++ whitespace()
  src := src ++ pstring("(result")
  val results = many1(match-type-id)
  results.foreach fn((rsrc, rtyp))
    src := src ++ rsrc
    typs := Cons(rtyp, typs)
  src := src ++ pstring(")")
  Just((src, typs.reverse))

fun match-func-type(): _ (string, wasm-type-list, wasm-type-list)
  var src := ""
  var ptyps := Nothing
  var rtyps := Nothing
  src := src ++ whitespace()
  src := src ++ pstring("(func")
  val params = optional(Nothing, match-func-params)
  val results = optional(Nothing, match-func-results)
  match params
    Nothing -> ()
    Just((srcs, typs)) ->
      src := src ++ srcs
      ptyps := Just(typs)
  match results
    Nothing -> ()
    Just((srcs, typs)) ->
      src := src ++ srcs
      rtyps := Just(typs)
  src := src ++ pstring(")")
  (src, ptyps, rtyps)

fun parse-type-field()
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(type")
  val (idx-src, idx) = match-idx-comment()
  src := src ++ idx-src
  val (func-src, params, results) = match-func-type()
  src := src ++ func-src
  src := src ++ pstring(")")
  // NOTE: The below match must contain a `_` branch, otherwise the code does
  // not run. Compilation will show a message that a default effect for `exn` was
  // added.
  match (params, results)
    (Just(ptyps), Just(rtyps)) -> save(Type(src, idx, Func-type(Just(ptyps), Just(rtyps))))
    (Just(ptyps), Nothing) -> save(Type(src, idx, Func-type(Just(ptyps), Nothing)))
    (Nothing, Just(rtyps)) -> save(Type(src, idx, Func-type(Nothing, Just(rtyps))))
    _ -> save(Type(src, idx, Func-type(Nothing, Nothing)))
  (src, src)

fun parse-many-type-fields()
  many(parse-type-field)

// (func ...) forms have: idx comment, type idx, params?, results?, locals?, comment blocks
// call_indirect which take a type idx parameter, block which take a result parameter.
// non-essential sexprs can be parsed as "unknown" sexpr

fun parse-module()
  val src = pstring("(module")
  save(Module(src))
  val types = parse-many-type-fields()
  types

fun parse-wat(s: string)
  parse(s.slice(), parse-module)

fun string(f: module-field)
  match f
    Module(s)     -> "Module: " ++ s
    Type(s, i, _) -> "Type(" ++ i.show ++ "): " ++ s
    Import(s)     -> "Import: " ++ s
    Func(s)       -> "Func:   " ++ s
    Other(s)      -> "Other:  " ++ s

fun main()
  val input = get-args().head
  match input
    Nothing -> println("Parser requires argument!")
    Just(s) ->
      var fields := []
      with fun save(it: module-field) fields := fields ++ [it]
      match parse-wat(s)
        ParseError(m, rr) ->
          println("Error: " ++ m.show)
          println("Remaining: " ++ rr.string.show)
        ParseOk(_, rr) ->
          println("Matched:")
          map(fields) fn(x)
            println(x.string)
          println("" ++ length(fields).show)
          println("Remaining: " ++ rr.string.show)