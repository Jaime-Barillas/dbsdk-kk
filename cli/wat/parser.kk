/*==============================================================================
 Wat Parser
 ----------
 Parse the subset of Wasm text format generated by running wasm2wat on
 WebAssembly generated by the Koka compiler. The code here is not very Koka
 idiomatic.
 
 TODO
 ----
 + Remove testing code.
 + Add tests.
 =============================================================================*/
module wat/parser

import std/text/parse

import std/os/env // FIXME: DELETE ME
import std/os/file // FIXME: DELETE ME
import std/os/path // FIXME: DELETE ME

type wasm-type
  I32
  I64
  F32
  F64

alias wasm-type-list = maybe<list<wasm-type>>

struct func-type
  params: wasm-type-list
  results: wasm-type-list

type module-field
  Module(src: string) // The module itself.
  Type(src: string, idx: int, typ: func-type)
  Import(src: string, idx: int, name: string, typ-idx: int)
  Func(src: string, idx: int, typ-idx: int)
  Export(src: string, name: string, func-idx: int)
  Other(src: string)

effect fun save(it: module-field): ()

fun match-idx-comment(): parse (string, int)
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(;")
  val idx = pnat()
  src := src ++ idx.show
  src := src ++ pstring(";)")
  (src, idx)

fun match-type-id(): _ (string, wasm-type)
  var src := ""
  src := src ++ whitespace()
  val typ-string = choose([{pstring("i32")},
                           {pstring("i64")},
                           {pstring("f32")},
                           {pstring("f64")}])
  val typ = match typ-string
    "i32" -> I32
    "i64" -> I64
    "f32" -> F32
    "f64" -> F64
    typ -> fail("Unknown Wasm type: " ++ typ)
  src := src ++ typ-string
  (src, typ)

fun match-func-params(): _ maybe<(string, list<wasm-type>)>
  var src := ""
  var typs := []
  src := src ++ whitespace()
  src := src ++ pstring("(param")
  val params = many1(match-type-id)
  params.foreach fn((psrc, ptyp))
    src := src ++ psrc
    typs := Cons(ptyp, typs)
  src := src ++ pstring(")")
  Just((src, typs.reverse))

fun match-func-results(): _ maybe<(string, list<wasm-type>)>
  var src := ""
  var typs := []
  src := src ++ whitespace()
  src := src ++ pstring("(result")
  val results = many1(match-type-id)
  results.foreach fn((rsrc, rtyp))
    src := src ++ rsrc
    typs := Cons(rtyp, typs)
  src := src ++ pstring(")")
  Just((src, typs.reverse))

fun match-func-type(): _ (string, wasm-type-list, wasm-type-list)
  var src := ""
  var ptyps := Nothing
  var rtyps := Nothing
  src := src ++ whitespace()
  src := src ++ pstring("(func")
  val params = optional(Nothing, match-func-params)
  val results = optional(Nothing, match-func-results)
  match params
    Nothing -> ()
    Just((srcs, typs)) ->
      src := src ++ srcs
      ptyps := Just(typs)
  match results
    Nothing -> ()
    Just((srcs, typs)) ->
      src := src ++ srcs
      rtyps := Just(typs)
  src := src ++ pstring(")")
  (src, ptyps, rtyps)

fun parse-type-field()
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(type")
  val (idx-src, idx) = match-idx-comment()
  src := src ++ idx-src
  val (func-src, params, results) = match-func-type()
  src := src ++ func-src
  src := src ++ pstring(")")
  // NOTE: The below match must contain a `_` branch, otherwise the code does
  // not run. Compilation will show a message that a default effect for `exn` was
  // added.
  match (params, results)
    (Just(ptyps), Just(rtyps)) -> save(Type(src, idx, Func-type(Just(ptyps), Just(rtyps))))
    (Just(ptyps), Nothing) -> save(Type(src, idx, Func-type(Just(ptyps), Nothing)))
    (Nothing, Just(rtyps)) -> save(Type(src, idx, Func-type(Nothing, Just(rtyps))))
    _ -> save(Type(src, idx, Func-type(Nothing, Nothing)))

fun match-string-content(): _ string
  fun is-string-char(ch: char) ch != '"'
  var src := ""
  src := src ++ chars-are("string content", is-string-char).string
  src
  
fun match-string(): _ (string, string)
  var src := ""
  src := src ++ whitespace()
  src := src ++ char('"').string
  val content = match-string-content()
  src := src ++ content
  src := src ++ char('"').string
  (src, content)

fun match-type-ref(): _ (string, int)
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(type")
  src := src ++ whitespace()
  val idx = pnat()
  src := src ++ idx.show
  src := src ++ pstring(")")
  (src, idx)

fun match-func-import(): _ (string, int, int)
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(func")
  val (idx-src, idx) = match-idx-comment()
  src := src ++ idx-src
  val (typ-src, typ-idx) = match-type-ref()
  src := src ++ typ-src
  src := src ++ pstring(")")
  (src, idx, typ-idx)

fun parse-import-field()
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(import")
  val (mod-src, mod) = match-string()
  src := src ++ mod-src
  val (name-src, name) = match-string()
  src := src ++ name-src
  val (func-src, idx, typ-idx) = match-func-import()
  src := src ++ func-src
  src := src ++ (pstring(")"))
  save(Import(src, idx, name, typ-idx))

fun skip-wasi-memory-import()
  whitespace()
  pstring("(import")
  match-string()
  match-string()
  whitespace()
  pstring("(memory")
  match-idx-comment()
  whitespace()
  pnat()
  char(')')
  char(')')

fun match-func-locals(): _ maybe<string>
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(local")
  val locals = many1(match-type-id)
  // locals type does not matter to us, but we do want to capture the text
  // source.
  foreach(locals) fn((lsrc, _))
    src := src ++ lsrc
  src := src ++ pstring(")")
  Just(src)

fun match-non-sexpr(): _ string
  val src = chars-are("Non-sexpr") fn(ch)
    ch != '(' && ch != ')'
  src.string

fun match-sexpr(): _ string
  var src := ""
  src := src ++ pstring("(")
  src := src ++ match-non-sexpr()
  src := src ++ pstring(")")
  src

fun parse-func-field()
  var src := ""
  src := src ++ whitespace()
  src := src ++ pstring("(func")
  val (idx-src, idx) = match-idx-comment()
  src := src ++ idx-src
  val (typ-src, typ-idx) = match-type-ref()
  src := src ++ typ-src
  val params = optional(Nothing, match-func-params)
  val results = optional(Nothing, match-func-results)
  val locals = optional(Nothing, match-func-locals)
  // We don't actually care about the param and result list beyond the text
  // source. Type info will be matched against the corresponding type field.
  match params
    Nothing -> ()
    Just((psrc, _)) -> src := src ++ psrc
  match results
    Nothing -> ()
    Just((rsrc, _)) -> src := src ++ rsrc
  match locals
    Nothing -> ()
    Just(lsrc) -> src := src ++ lsrc
  src := src ++ match-non-sexpr()
  val more-body = many fn()
    val sexpr = match-sexpr()
    val rest = optional("", match-non-sexpr)
    sexpr ++ rest
  foreach(more-body) fn(s)
    src := src ++ s
  src := src ++ pstring(")")
  save(Func(src, idx, typ-idx))

fun parse-other-field()
  var src := ""
  src := src ++ whitespace()
  // There may be Other fields before or after the group of exports. We need to
  // make sure we don't accidentally consume them.
  val maybe-export = starts-with(current-input().extend(6).string, "(export")
  match maybe-export
    Just -> ()
    Nothing ->
      // Just take the whole line.
      src := src ++ chars-are("Other field", fn(ch) {ch != '\n'}).string
  // NOTE: Sometimes there may be no "Other" fields before exports. `src` will
  // only contain whitespace in this case. Not really an "Other" field in this
  // case, but that doesn't matter.
  save(Other(src))

fun parse-module()
  val src = pstring("(module")
  save(Module(src))
  many(parse-type-field)
  many(parse-import-field)
  optional(' ', skip-wasi-memory-import) // Appears in SIDE_MODULE compilation of custom wasi code
  many(parse-func-field)
  many(parse-other-field)

fun parse-wat(s: string)
  parse(s.slice(), parse-module)

fun string(f: module-field)
  match f
    Module(s) -> "Module: " ++ s
    Type(s, i, _) -> "Type(" ++ i.show ++ "): " ++ s
    Import(s, i, n, _) -> "Import(" ++ i.show ++ ") - " ++ n ++ ": " ++ s
    Func(_, i, ti) -> "Func(" ++ i.show ++ ", " ++ ti.show ++ ")"
    Export(s, n, fi) -> "Export(" ++ fi.show ++ "): " ++ n
    Other(s) -> "Other:  " ++ s

fun main()
  val input = get-args().head
  match input
    Nothing -> println("Parser requires argument!")
    Just(s) ->
      var fields := []
      with fun save(it: module-field) fields := fields ++ [it]
      match parse-wat(read-text-file(path(s)))
        ParseError(m, rr) ->
          println("Error: " ++ m.show)
          println("Remaining: " ++ rr.string.show)
        ParseOk(_, rr) ->
          println("Matched:")
          map(fields) fn(x)
            println(x.string)
          println("" ++ length(fields).show)
          println("Remaining: " ++ rr.string.show)